<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title>Cellular automata epidemic model</title>
    </head>
    <body>
    <style media="screen">*{margin: 0;padding:0}</style>
        <canvas id="canvas" width="1200" height="600"></canvas>
        <div id="info"></div>
        <script type="text/javascript">
            Number.prototype.mod = function(n) {
                return ((this % n) + n) % n;
            };
            
            var info = document.getElementById('info');
            var canvas = document.getElementById('canvas');
            var ctx = canvas.getContext('2d');

            ctx.beginPath();
            ctx.fillStyle = '#333';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            var state = {
                susceptible: '#cccc00',
                infected: '#ff0000',
                removed: '#000000',
            }

            function agent(state){
                this.state = state;
                this.lastChange = 0;
            }

            function* mooreTorusNeighborhood(posX, posY, grid){
                for (var i = -1; i <= 1; i++)
                    for (var j = -1; j <= 1; j++)
                        if(i || j)
                            yield grid.matrix[(posX + i).mod(grid.width)][(posY + j).mod(grid.height)];
            }

            function mooreTorusNeighborhoodArr(posX, posY, grid){
                return [...mooreTorusNeighborhood(posX, posY, grid)];
            }

            function kermackModel(pInfect, pRecover, wrapFactor){
                this.pInfect = pInfect;
                this.pRecover = pRecover;
                this.wrapFactor = wrapFactor;
            }

            function numOf(value, arr){
                var result = 0;
                for (var i = 0; i < arr.length; i++)
                    result += value == arr[i].state;

                return result;
            }

            kermackModel.prototype.nextState = function(agent, neighbours, generation){
                var rnd = Math.random(),
                    infectedNighbours = numOf(state.infected, neighbours);
                agent.lastChange++;
                if(agent.state == state.susceptible && rnd < (1 - Math.pow(1 - this.pInfect, infectedNighbours))){
                    agent.state = state.infected;
                    agent.lastChange = 0;
                }else if(agent.state == state.infected && rnd < this.pRecover){
                    agent.state = state.removed;
                    agent.lastChange = 0;
                }else if(agent.state == state.removed && agent.lastChange > this.wrapFactor){
                    agent.state = state.susceptible;
                    agent.lastChange = 0;
                }
            }

            function grid(width, height, neighboursExtractor, model){
                this.width = width || 100;
                this.height = height || 100;
                this.neighboursExtractor = neighboursExtractor;
                this.model = model;
                this.matrix = [[]];
                this.generation = 0;
                this.stats = {};
            }

            grid.prototype.randomInit = function(ifectedProbability){
                for (var i = 0; i < this.width; i++) {
                    for (var j = 0; j < this.height; j++) {
                        var rndState = Math.random() < ifectedProbability ? state.infected : state.susceptible;
                        this.matrix[i].push(new agent(rndState));
                    }
                    if(i != this.width - 1)
                        this.matrix.push([]);
                }
                this.updateStats();
            }

            grid.prototype.render = function(ctx){
                var origin = {x: 0, y: 0},
                    cellSize = 6,
                    cellPadding = 0;

                for (var i = 0; i < this.width; i++) {
                    for (var j = 0; j < this.height; j++) {
                        var color = this.matrix[i][j].state;
                        ctx.fillStyle = color;
                        ctx.fillRect(i * (cellSize + cellPadding),
                                    j * (cellSize + cellPadding),
                                    cellSize, cellSize);
                    }
                }
            }

            grid.prototype.nextState = function(){
                var matrixCpy = copy(this.matrix);
                for (var i = 0; i < this.width; i++) {
                    for (var j = 0; j < this.height; j++) {
                        var neighbours = this.neighboursExtractor(i, j, this);
                        this.model.nextState(matrixCpy[i][j], neighbours, this.generation++);
                    }
                }

                this.matrix = matrixCpy;
                this.updateStats();
            }

            grid.prototype.renderStats = function(ctx){
                for (var propName in this.stats) {
                    var yVals = this.stats[propName];
                    ctx.beginPath();
                    ctx.strokeStyle = propName;
                    ctx.lineWidth = 3;
                    var yScale = this.width * this.height;
                    var xScale = 600 / yVals.length;
                    for (var i = 1; i < yVals.length; i++) {
                        var x1 = (i - 1) * xScale;
                        var y1 = yVals[i - 1] / yScale * 600;
                        var x2 = i * xScale;
                        var y2 = yVals[i] / yScale * 600;
                        ctx.moveTo(x1, 600-y1);
                        ctx.lineTo(x2, 600-y2);
                    }
                    ctx.stroke();
                    ctx.closePath();
                }
            }

            grid.prototype.updateStats = function(){
                var totalNumSnaps = 50;
                var snapshot = {};
                for (var i = 0; i < this.width; i++){
                    for (var j = 0; j < this.height; j++){
                        if(snapshot[this.matrix[i][j].state] != undefined)
                            snapshot[this.matrix[i][j].state]++;
                        else
                            snapshot[this.matrix[i][j].state] = 0;
                    }
                }
                for (var propName in snapshot) {
                    if (this.stats.hasOwnProperty(propName)) {
                        this.stats[propName].push(snapshot[propName]);
                        if(this.stats[propName].length > totalNumSnaps)
                            this.stats[propName].shift();
                    }else {
                        this.stats[propName] = [];
                    }
                }
            }

            var world = new grid();
            world.neighboursExtractor = mooreTorusNeighborhoodArr;
            world.model = new kermackModel(0.5, 0.1, 70);
            world.randomInit(0.0001);
            var cnt = 0;

            function animate(){
                ctx.fillStyle = '#fff';
                ctx.fillRect(0,0,canvas.width, canvas.height)
                world.nextState();
                ctx.translate(600, 0);
                world.renderStats(ctx);
                ctx.translate(-600, 0);
                world.render(ctx);
                window.requestAnimationFrame(animate);
                info.innerHTML = cnt++;
            }

            animate();

            function copy(obj){
                return JSON.parse(JSON.stringify(obj));
            }

        </script>
    </body>
</html>
